# DiseaseDetectionApp/core/ml_processor.py
import torch
import os
import json
import re
from PIL import Image
from torchvision import models, transforms
from .wikipedia_integration import get_wikipedia_summary # --- IMPORT FOR WEB SEARCH ---
from .google_search import search_google_for_summary # --- IMPORT FOR WEB SEARCH ---

# --- Import fuzzywuzzy for better text matching ---
try:
    from fuzzywuzzy import process
except ImportError:
    process = None

# --- Configuration Constants ---
# Define paths relative to this file's location.
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_PATH = os.path.join(BASE_DIR, '..', 'disease_model.pt')
CLASS_MAP_PATH = os.path.join(BASE_DIR, '..', 'class_to_name.json')
IMG_SIZE = 224

# --- Confidence Thresholds & Special Classes ---
# You can adjust these values to make the diagnosis stricter or more lenient.
IMAGE_CONFIDENCE_THRESHOLD = 0.50  # Minimum confidence (0.0 to 1.0) for a confident diagnosis.
SYMPTOM_CONFIDENCE_THRESHOLD_STRONG = 75 # Score (out of 100) for a symptom match to be strong.
SYMPTOM_CONFIDENCE_THRESHOLD_WEAK = 60   # Minimum score for a symptom match to be considered.
# Add names of folders that represent a healthy state. This is crucial for avoiding false positives.
HEALTHY_CLASS_NAMES = ('healthy', 'normal', 'clear_skin')


def get_custom_labels():
    """Loads the class-to-name mapping generated by the training script."""
    if not os.path.exists(CLASS_MAP_PATH):
        print(f"FATAL ERROR: Class mapping file not found at '{CLASS_MAP_PATH}'.")
        print("Please run 'train_disease_classifier.py' to create it.")
        return None
    try:
        with open(CLASS_MAP_PATH, 'r', encoding='utf-8') as f:
            class_to_name = json.load(f)
        return {int(k): v for k, v in class_to_name.items()}
    except (json.JSONDecodeError, Exception) as e:
        print(f"Error reading or parsing class mapping file: {e}")
        return None

class MLProcessor:
    """Handles loading the model and running predictions with advanced confidence checks."""
    def __init__(self):
        print("Initializing custom AI model processor...")
        self.labels = get_custom_labels()
        self.model = None
        self.num_classes = 0

        if not self.labels:
            print("Could not initialize MLProcessor because class labels are missing.")
            return

        self.num_classes = len(self.labels)
        print(f"Found {self.num_classes} classes: {list(self.labels.values())}")

        self.model = models.mobilenet_v2(weights=None)
        self.model.classifier[1] = torch.nn.Linear(self.model.last_channel, self.num_classes)

        if not os.path.exists(MODEL_PATH):
            print(f"FATAL ERROR: Custom model file not found at '{MODEL_PATH}'.")
            self.model = None
            return

        try:
            self.model.load_state_dict(torch.load(MODEL_PATH, map_location='cpu'))
            self.model.eval()
            print("Custom disease detection model loaded successfully.")
        except Exception as e:
            print(f"An error occurred while loading the model state dictionary: {e}")
            self.model = None

        self.transform = transforms.Compose([
            transforms.Resize((IMG_SIZE, IMG_SIZE)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])

    def predict_from_image(self, image_path, domain, database):
        """Analyzes an image and returns a diagnosis aware of healthy and uncertain states."""
        if not self.model:
            return None, 0, "The AI model is not loaded.", "Error"

        try:
            img = Image.open(image_path).convert('RGB')
            img_t = self.transform(img)
            batch_t = torch.unsqueeze(img_t, 0)

            with torch.no_grad():
                logits = self.model(batch_t)
                probabilities = torch.nn.functional.softmax(logits, dim=1)[0]
                top_prob, top_idx = torch.max(probabilities, 0)
            
            primary_confidence = top_prob.item()
            predicted_class_name = self.labels.get(top_idx.item(), "Unknown")
            
            num_top_predictions = min(3, self.num_classes)

            if predicted_class_name.lower() in HEALTHY_CLASS_NAMES:
                healthy_result = {
                    'name': 'Healthy',
                    'description': 'The model predicts the sample is healthy and shows no signs of the diseases it was trained on.',
                    'solution': 'No action needed. Continue with normal preventive care.',
                    'other_possibilities': []
                }
                return healthy_result, primary_confidence * 100, "No Wikipedia summary needed for healthy state.", "Healthy"

            if primary_confidence < IMAGE_CONFIDENCE_THRESHOLD:
                top_k_probs, top_k_indices = torch.topk(probabilities, num_top_predictions)
                other_possibilities = []
                for i in range(top_k_probs.size(0)):
                    weak_conf = top_k_probs[i].item()
                    weak_name = self.labels.get(top_k_indices[i].item(), "Unknown")
                    if weak_conf > 0.05:
                        other_possibilities.append(f"{weak_name} ({weak_conf:.1%})")
                
                uncertain_result = {
                    'name': 'No Confident Match Found',
                    'description': 'The AI model could not identify a known disease with high confidence.',
                    'solution': 'For a definitive diagnosis, please consult a qualified professional.',
                    'other_possibilities': other_possibilities
                }
                return uncertain_result, primary_confidence * 100, "No specific disease was identified.", "Uncertain"

            best_match_disease = next((d for d in database if d.get("name", "").lower() == predicted_class_name.lower()), None)
            
            if best_match_disease:
                _, top_k_indices = torch.topk(probabilities, num_top_predictions)
                other_possibilities = [f"{self.labels.get(idx.item(), 'Unknown')} ({probabilities[idx].item():.1%})" for idx in top_k_indices[1:]]
                best_match_disease['other_possibilities'] = other_possibilities
                wiki_summary = get_wikipedia_summary(best_match_disease['name'])
                return best_match_disease, primary_confidence * 100, wiki_summary, "Detected from Image"
            else:
                # --- NEW: WEB SEARCH FALLBACK ---
                print(f"AI prediction '{predicted_class_name}' not in local DB. Attempting web search...")
                google_summary = search_google_for_summary(predicted_class_name)
                wiki_summary = get_wikipedia_summary(predicted_class_name)

                if google_summary and "Could not perform search" not in google_summary:
                    web_result = {
                        'name': predicted_class_name.replace('_', ' ').title(),
                        'description': google_summary,
                        'solution': 'No local data available. Please consult online resources or a professional.',
                        'other_possibilities': []
                    }
                    return web_result, primary_confidence * 100, wiki_summary, "Found via Web Search"
                else:
                    error_msg = f"AI's prediction '{predicted_class_name}' was not found in the local database, and an online search failed."
                    return None, 0, error_msg, "Database Mismatch"

        except Exception as e:
            if "selected index k out of range" in str(e):
                 error_msg = f"Model has only been trained on {self.num_classes} diseases, but code tried to fetch more."
                 return None, 0, error_msg, "Model Configuration Error"
            print(f"Unexpected error during image prediction: {e}")
            return None, 0, f"An error occurred while processing the image: {e}", "Processing Error"

def predict_from_symptoms(symptoms, domain, database):
    """Predicts a disease from symptoms with graded confidence levels."""
    if process is None:
        return None, 0, "The 'fuzzywuzzy' library is not installed.", "Library Missing"

    domain_candidates = {d['name']: d for d in database if d.get("domain", "").lower() == domain.lower()}
    if not domain_candidates:
        return None, 0, f"No diseases found for the '{domain}' domain.", "Not applicable"

    choices = {name: f"{name} {data.get('description', '')} {' '.join(data.get('stages', {}).values())} {data.get('causes', '')}".lower() for name, data in domain_candidates.items()}
    results = process.extract(symptoms.lower(), choices, limit=3)
    
    if not results or results[0][1] < SYMPTOM_CONFIDENCE_THRESHOLD_WEAK:
        return None, 0, "Could not find a strong match for the specified symptoms.", "Not applicable"

    best_match_name, primary_confidence, _ = results[0]
    best_match_disease = domain_candidates[best_match_name]

    other_possibilities = [f"{name} ({score}%)" for name, score, _ in results[1:] if score > 50]
    best_match_disease['other_possibilities'] = other_possibilities
    
    wiki_summary = get_wikipedia_summary(best_match_disease['name'])
    
    predicted_stage = "Uncertain (Possible Match)" if primary_confidence < SYMPTOM_CONFIDENCE_THRESHOLD_STRONG else "Inferred from Symptoms"
        
    return best_match_disease, primary_confidence, wiki_summary, predicted_stage

